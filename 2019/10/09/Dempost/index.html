<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="OverviewThis  is my undergradute thesis at Fudan University, when I was pursuing a BS in ME. It mainly studies the mechanical model of particles based">
    

    <!--Author-->
    
        <meta name="author" content="Xuefei Li">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Dempost"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="XuefeiLi(李雪霏)"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>Dempost - XuefeiLi(李雪霏)</title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/main.css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!--Favicon-->
    
        <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    

<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Menu -->
<!-- Navigation -->
<header>
    <div class="logo">
        <a href="/">XuefeiLi(李雪霏)</a>
    </div><!-- end logo -->

    <div id="menu_icon"></div>
    <nav>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives">Archives</a>
            </li>
            
        </ul>
    </nav><!-- end navigation menu -->

</header><!-- end header -->


<!-- Main Content -->
<section class="main clearfix">

    <section class="top" style="background: url('/assets/header.jpeg');">
        <div class="wrapper content_header clearfix">
            

<div class="work_nav">

    <ul class="btn clearfix">
        
        <li><a href="/2019/10/27/undersea/" class="previous" data-title="Undersea Game"></a></li>
        
        <li><a href="/" class="grid" data-title="Portfolio"></a></li>
        
        <li><a href="/2019/10/08/Texture-map/" class="next" data-title="Texture map"></a></li>
        
    </ul>

</div><!-- end work_nav -->
            <h1 class="title">Dempost</h1>
        </div>
    </section><!-- end top -->

    <section class="wrapper">
        <div class="content">

            <!-- Gallery -->
            

            <!-- Content -->
            <p><img src="/assets/dempost/dem.gif" alt="dem"></p>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>This  is my undergradute thesis at Fudan University, when I was pursuing a BS in ME. It mainly studies the mechanical model of particles based on discrete element method and develops a complete post-processing software: DEMPost. I used OpenGL to visualize the animation of Particle Flow. This is my first step into Computer Graphics, I was overwhelmed by its charm. </p>
<p>Particles are common form of matter in nature and are also ubiquitous in production and life; Discrete Element Method(DEM) is a numerical method used to calculate how large particles move under given conditions. This passage only talks about the software part of the thesis, to see the full version in Chinese <a href="https://drive.google.com/file/d/1w5BFQWmnvTEH_t2XbZgwuxoL_Jj9EsHe/view?usp=sharing" target="_blank" rel="noopener">Thesis</a>.</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The design and development of discrete element post-processing software DEMPost is the most important part of my work. Post-processing program is an important auxiliary of discrete-element numerical simulation program. This paper develops DEMPost with ApenPost as an example. In addition to satisfying the basic requirements of post-processing program to visualize and post-process discrete element models and related variables, I also added loading of discrete-element calculation data, animated display over time, and histograms showing the distribution and changes of main variables (mass, velocity, acceleration, etc). It also have strong interactivity. The design, development and maintenance of the software are all done independently by Xuefei Li from January to May 2018.</p>
<p>The discrete element post-processor needs to be developed and used with a graphics supported system with strong interactivity and sufficient memory space for operations. This software was developed on MacBook Pro (15-inch, 2016). The system configuration is 2.6 GHz Intel Core i7, 16 GB 2133 MHz LPDDR3, Intel HD Graphics 530 1536 MB. DEMPost post-processor chooses Python, which is an advanced object-oriented, dynamic data type advanced computer programming language that follows the GPL (GNU General Public License) protocol. </p>
<p>The main function of this software is to visualize the discrete element numerical simulation results, I choose OpenGL (Open Graphics Library) as the application interface. OpenGL is a professional graphical program interface for cross-platform and programming languages. It is powerful, rich and easy to use. It is mainly used to process 3D images and is also suitable for 2D images. In CAD, Virtual Reality, scientific visualization programs and video game development, etc. wxPython is an excellent cross-platform GUI library for Python, adding a number of extensions to wxWidgets that encapsulate other famous GUI graphics library for Python. With wxPython, you can design a robust and practical GUI; this article also uses other libraries, such as numpy, matplotlib, etc., which will be briefly explained later. In this chapter, I will introduce the DEMPost program structure and the interfaces used.</p>
<p>DEMPost includes, but are not limited to, the following functions: reading and loading data of the particle stream, including particle states (position, velocity, acceleration, etc.) at different times and rendering; animating the particle stream according to time series; animating particle flow of independent physical quantities according to time series; reading, loading and drawing force chain data (position, size, etc.) ; the force chain is animated according to the time series; performing statistics and drawing histogram of the physical quantities of force chain (velocity, Acceleration, size, etc.); drawing and animation of velocity acceleration fields at different moments; strong interactive functions, which allow the users to rotate, pan, zoom in/out, etc. directly through the mouse and keyboard.</p>
<p>Since the passage is too long, you can simply take a look at the Manual. However, the remaining parts talk about the implementation of the software, you can skip them.</p>
<h3 id="Manual"><a href="#Manual" class="headerlink" title="Manual"></a>Manual</h3><ol>
<li>Import and visualization of particle data</li>
</ol>
<p>“File-&gt;Import” (Ctrl+I), defined in the form class canvas-Frame, using wxPython’s directory dialog wx.DirDialog to pass the selected file/folder location as a parameter to In the DEMPost class,</p>
<p><img src="/assets/dempost/dem3.png" alt="dem3"></p>
<p>The data is calculated with DEM, which is stored inr the folder ForceeChain20170426, and the state data of the particles is in the subfolder /file. Each dat file in the catalog represents the flow of particles at a certain time, where each row represents a particle, a total of 21 columns. Information of data structure is explained in ReadMe.dat. In order to improve efficiency, load_data.py performs data cleaning, leaving only the following information of position, velocity and acceleration: (x_i, y_i, z_i, v{xi}, v{yi}, v{zi}, a{xi}, a{yi}, a{zi}) i=1, 2, 3,…. The list is passed to DEMPost.</p>
<ol start="2">
<li>Parameter settings</li>
</ol>
<p>After the file is determined, determine the object type of the model, select it in “File-&gt;Object” (Ctrl+O), use wxPython’s select list dialog box, “Particle Flow”, “Force Chain”, “Velocity”, “Acceleration” to select the four objects, and select the result that passed to DEMPost,</p>
<p><img src="/assets/dempost/dem4.png" alt="dem4"></p>
<p>After the file is determined, determine the object type of the model, select it in “File-&gt;Object” (Ctrl+O), use wxPython’s select list dialog box, “Particle Flow”, “Force Chain”, “Velocity”, “Acceleration” to select the four objects, and select the result that passed to DEMPost.</p>
<p>To draw a particle flow model, you only need to use the coordinates, and pass the collection of individual particle coordinates to the combination class Particles.<br>Note that ParticleFlow also needs another parameter magnify, which represents the scaling factor of the particle coordinates, which is changed by “Edit-&gt;Parameter”(Ctrl+E). The process is as follows, click on the “Parameter” trigger text input dialog box, and the obtained user input is passed to the DEMPost canvas layer.</p>
<ol start="3">
<li>Particle Flow visualization</li>
</ol>
<p>When the parameters are set, the particles can be drawn. In the menu bar, “Display-&gt;Show” (Ctrl+R), the implementation process is the same as the binding event mentioned in the previous two sections. The processed data is imported to the Particle stream datalist on DEMPost canvas to update canvas. Notice that there are no boundaries in the diagram, click “File-&gt;Import” Border to execute:</p>
<p><img src="/assets/dempost/dem5.png" alt="dem5"></p>
<p>Use toolbar to control animation(Start, stop, next frame, previous frame).  “Display-&gt;Clear(Ctrl+W)” clear the canvas and set the datalist, vellist, alist, linklist in the DEMPost canvas to an empty list to refresh the canvas.</p>
<p><img src="/assets/dempost/dem6.png" alt="dem6"></p>
<ol start="4">
<li>Velovity visualization</li>
</ol>
<p>“File-&gt;Object”(Ctrl+O): select “Velocity” in the pop-up dialog box, the result is passed to the DEMPost canvas, and the datatype becomes”‘Velocity”.</p>
<p>Since velocity is a vector, creating a composite class Vector in node.py. The particle velocity vector consists of particles and velocity vectors. It is an arrow shape consists of a Sphere and a Vector. The sphere is in the center of the corresponding particle, representing the position of the particle, Vector represents the velocity vector, the arrow points to the direction of the velocity vector, and the mode and velocity vector in proportion to the model,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span><span class="params">(HierarchicalNode)</span>:</span> <span class="comment"># the mode of the vector is 1, r is the radius</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, l, r)</span>:</span></span><br><span class="line">				super(Vector, self).__init__() </span><br><span class="line">        self.child_nodes = [Cylinder(), Cone()] </span><br><span class="line">        self.child_nodes[<span class="number">0</span>].color_index = <span class="number">1</span> </span><br><span class="line">        self.child_nodes[<span class="number">0</span>].scale(r, r, l) </span><br><span class="line">        self.child_nodes[<span class="number">1</span>].color_index = <span class="number">2</span> </span><br><span class="line">        self.child_nodes[<span class="number">1</span>].translate(<span class="number">0</span>, <span class="number">0</span>, l) </span><br><span class="line">        self.child_nodes[<span class="number">1</span>].scale(r, r, r)</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManyVectors</span><span class="params">(HierarchicalNode)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p, di, mag)</span>:</span></span><br><span class="line">        super(ManyVectors, self).__init__() </span><br><span class="line">        self.child_nodes = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p)):</span><br><span class="line">        		self.child_nodes.append(Sphere()) </span><br><span class="line">            self.child_nodes[index].scale(<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>) 		</span><br><span class="line">            self.child_nodes[index].translate(p[i][<span class="number">0</span>]*mag, p[i][<span class="number">1</span>]*mag,p[i][<span class="number">2</span>]*mag)</span><br><span class="line">        		self.child_nodes[index].color_index = <span class="number">7</span></span><br><span class="line">        		cl = sqrt(di[i][<span class="number">0</span>]*di[i][<span class="number">0</span>]+di[i][<span class="number">1</span>]*di[i][<span class="number">1</span>]+di[i][<span class="number">2</span>]*di[i][<span class="number">2</span>])*mag</span><br><span class="line">        		self.child_nodes.append(Vector(cl, <span class="number">0.3</span>)) self.child_nodes[index].rotate(di[i][<span class="number">0</span>], di[i][<span class="number">2</span>], di[i][<span class="number">1</span>]) </span><br><span class="line">            self.child_nodes[index].translate(p[i][<span class="number">0</span>]*mag, p[i][<span class="number">1</span>]*mag, p[i][<span class="number">2</span>]*mag)</span><br></pre></td></tr></table></figure>

<p>Like the particle stream, the value passed in DEMPost also represents the number of frames in the picture. It can be animated and controlled by the four buttons of the toolbar. It can be seen from the animation that when the particles are deposited at the bottom, the velocity is small. When some particles move above the boundary, the overall velocity becomes larger, the bottom velocity is upward, and the velocity is reversed after collision with the upper edge, and the particles are scattered around during the falling process. The velocity vector is radial. The velocity cloud map is used to represent the velocity,</p>
<p><img src="/assets/dempost/dem7.png" alt="dem7"></p>
<p><img src="/assets/dempost/dem8.png" alt="dem8"></p>
<ol start="5">
<li>Acceleration visualization</li>
</ol>
<p>Acceleration vector diagram is similar to velocity. In order to distinguish, the author changed the color and adjusted to the appropriate parameter.</p>
<p><img src="/assets/dempost/dem9.png" alt="dem9"></p>
<p><img src="/assets/dempost/dem10.png" alt="dem10"></p>
<ol start="6">
<li>Velocity and acceleration statistics</li>
</ol>
<p>n order to observe the distribution of particle flow velocity and acceleration, DEMPost provides the function of displaying the histogram of variable distribution. Click “Display-&gt;Plot”</p>
<p><img src="/assets/dempost/dem11.png" alt="dem11"></p>
<p><img src="/assets/dempost/dem12.png" alt="dem12"></p>
<p>The object of statistics is the modulus of all velocities and accelerations, using the wxPython backend of matplotlib, creating the FigureCnavas object, embedding matplotlib into the GUI.</p>
<p><img src="/assets/dempost/dem13.png" alt="dem13"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_wxagg <span class="keyword">import</span> FigureCanvasWxAgg <span class="keyword">as</span> FigureCanvas</span><br><span class="line"><span class="keyword">from</span> matplotlib.backends.backend_wx <span class="keyword">import</span> NavigationToolbar2Wx <span class="keyword">from</span> matplotlib.figure </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanvasPanel</span><span class="params">(wx.Panel)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, plot_data1, plot_data2)</span>:</span></span><br><span class="line">				wx.Panel.__init__(self, parent)</span><br><span class="line">				<span class="comment"># velocity</span></span><br><span class="line">				self.figure = Figure(figsize=(<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line">				self.axes = self.figure.add_subplot(<span class="number">211</span>) </span><br><span class="line">        self.axes.hist(plot_data1, <span class="number">40</span>, normed=<span class="literal">True</span>) </span><br><span class="line">        self.axes.set_title(<span class="string">'Velocity'</span>) </span><br><span class="line">        self.axes.set_ylabel(<span class="string">'count'</span>)</span><br><span class="line">				<span class="comment"># acceleration</span></span><br><span class="line">				self.axes = self.figure.add_subplot(<span class="number">212</span>) </span><br><span class="line">        self.axes.hist(plot_data2, <span class="number">40</span>, normed=<span class="literal">True</span>) </span><br><span class="line">        self.axes.set_title(<span class="string">'Acceleration'</span>) </span><br><span class="line">        self.axes.set_ylabel(<span class="string">'count'</span>)</span><br><span class="line">				self.canvas = FigureCanvas(self, <span class="number">-1</span>, self.figure) </span><br><span class="line">        self.sizer = wx.BoxSizer(wx.VERTICAL) </span><br><span class="line">        self.sizer.Add(self.canvas, <span class="number">1</span>, wx.LEFT | wx.TOP | wx.GROW) </span><br><span class="line">        elf.SetSizer(self.sizer)</span><br><span class="line">				self.Fit()</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Force chain visualization</li>
</ol>
<p>Force chain grids are often used in particle mechanics methods to represent the amount of force that exists between each pair of particles. DEMPost can also load and visualize a 3D force chain network. The force chain data/chains are also imported via File-&gt;Import(Ctrl+I). The data structure in each file is as follows,</p>
<p><img src="/assets/dempost/dem14.png" alt="dem14"></p>
<p>Each row represents a force chain, the ith rows 1, 2, and 3 represent the xyz coordinates of the first and first particles in the i-th force chain in the force chain, and the fourth, fifth, and sixth columns represent the xyz coordinates of the second particle. Column 7 represents the magnitude of the force. In order to simplify the model, the force chain is regarded as a ManyVector arrow. The starting point is the first particle and the ending point is the second particle. The thickness of the wire is proportional to the force.</p>
<p><img src="/assets/dempost/dem15.png" alt="dem15"></p>
<p><img src="/assets/dempost/dem16.png" alt="dem16"></p>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><ol>
<li>3D Modeling and OpenGL</li>
</ol>
<p>Computer-Aided Design (CAD) models the 3D world and creates and designs it on a computer. The key step in 3D modeling is rendering, which is to store and render as many and complex objects as possible, while keeping the rendering program less complex. Before rendering, you first need to create a window, because the graphics-driven manipulation is not enough, so you need to use a cross-platform image application interface OpenGL and OpenGL tool library GLUT to manage the window.</p>
<p>The render object of OpenGL is a polygon composed of vertices and normal vectors. Currently OpenGL has two branches: traditional OpenGL and modern OpengL. Traditional OpenGL provides a fixed pipeline. By adjusting global variables, developers can enable or disable some rendering features such as lighting, shading, and more. Next, OpenGL automatically renders the scene based on the features selected; modern OpenGL uses a programmable pipeline instead of a fixed pipeline, and developers only need to write shaders applets on graphics hardware such as GPUs. Traditional methods are relatively simple, and this article still uses traditional OpenGL programming. GLUT is a library bundled with OpenGL that creates an action window callbacks for the user interface. Due to the high requirements for frame management and user interface in this article, a complete library is required, thus wxPython interface is also used later.</p>
<p>In computer graphics, the basic elements are coordinate systems, points, vectors, and transformation matrices. The coordinate system consists of the origin and three basic vectors, denoted as the x-axis, y-axis, and z-axis; points in 3D coordinates can be represented as offsets to the origin in the x, y, and z directions. The vector represents the difference between the two points in the x-axis, y-axis, and z-axis directions; the transformation matrix can realize the conversion between coordinate systems. To convert a vector ν in one coordinate system to another, you can multiply a transformation matrix M:</p>
<p>v` = Mv</p>
<p>Common transformations include panning, zooming in/out, rotating, etc., which are called affine transformations. Figure below shows some of the transformations required from the physical object to the screen. The right half of the figure is the transformation of the object coordinate system (eye space) to the screen view (Viewort Space) can be implemented with OpenGL’s own functions; the inverse transformation from the object coordinate system to the screen view can be handled by gluPerspective, from Normalized device space, the conversion to the screen view can be processed by glViewport, and the two matrices are multiplied and stored as a GL PROJECTION matrix. The left half of the figure is implemented by the developer, defining a transformation matrix from the point in the model to the entity object as the model matrix, and then defining a transformation matrix from the entity object to the eye as the view matrix (view matrix ) view matrix, these two matrices are combined to get the ModelView matrix. The transformation of the 3D model The matrix is a four-dimensional matrix, because in the translation transformation, the fourth element determines whether the tuple is a point or a vector in space.</p>
<ol start="2">
<li>Fundamental architecture of OpenGL</li>
</ol>
<p>First, configure the lab environment and install python-opengl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt−get install python−opengl</span><br></pre></td></tr></table></figure>

<p>Once installed, you can start building the viewer class DEMPost, which is implemented in viewer.py.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DEMPost</span><span class="params">(MyCanvasBase)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">InitGL</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="string">""" Initialize the viewer. """</span> self.scene = Scene()</span><br><span class="line">       <span class="keyword">if</span> self . size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">       self.size = self.GetClientSize()</span><br><span class="line">       self .w, self .h = self . size</span><br><span class="line">       <span class="comment"># position viewer</span></span><br><span class="line">       glMatrixMode (GL_MODELVIEW) glTranslatef (<span class="number">0.0</span> , <span class="number">0.0</span> , −<span class="number">2.0</span>)</span><br><span class="line">       <span class="comment"># position object</span></span><br><span class="line">       glRotatef(self.y, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>) glRotatef(self.x, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line">               print(<span class="string">"\033[4;30;102m INITIALIZE GL \033[0m"</span>)</span><br><span class="line">               glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB)</span><br><span class="line">           		glEnable(GL_CULL_FACE)</span><br><span class="line">               glCullFace(GL_BACK)</span><br><span class="line">               glEnable(GL_DEPTH_TEST)</span><br><span class="line">               glDepthFunc(GL_LESS)</span><br><span class="line">               glEnable(GL_LIGHT0)</span><br><span class="line">               glLightfv(GL_LIGHT0, GL_POSITION, GLfloat_4(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)) 		</span><br><span class="line">               glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, GLfloat_3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>)) </span><br><span class="line">               glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE) </span><br><span class="line">               glEnable(GL_COLOR_MATERIAL)</span><br><span class="line">               glClearColor(<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>

<p>Then rendering functions, update the buffer area,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnDraw</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">""" The render pass for the scene """</span> self.init_view()</span><br><span class="line">    glEnable (GL_LIGHTING)</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</span><br><span class="line">        <span class="comment"># Load the modelview matrix from the current state of the trackball</span></span><br><span class="line">        glMatrixMode(GL_MODELVIEW)</span><br><span class="line">        glPushMatrix()</span><br><span class="line">        glLoadIdentity()</span><br><span class="line">        <span class="comment"># store the inverse of the current modelview.</span></span><br><span class="line">        currentModelView = numpy.array(glGetFloatv(GL_MODELVIEW_MATRIX)) </span><br><span class="line">        self.modelView = numpy.transpose(currentModelView) </span><br><span class="line">        self.inverseModelView = inv(numpy.transpose(currentModelView))</span><br><span class="line">        <span class="comment"># render the scene. This will call the render function for each object in the scene</span></span><br><span class="line">        self.scene.render()</span><br><span class="line">        <span class="comment"># draw the grid</span></span><br><span class="line">        glCallList(G_OBJ_PLANE)</span><br><span class="line">        <span class="comment"># flush the buffers so that the scene can be drawn glPopMatrix()</span></span><br><span class="line">        self .SwapBuffers()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_view</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="string">""" initialize the projection matrix """</span></span><br><span class="line">      xSize, ySize = glutGet(GLUT_WINDOW_WIDTH), glutGet(GLUT_WINDOW_HEIGHT)</span><br><span class="line">      aspect_ratio = float(xSize) / float(ySize)</span><br><span class="line">  		<span class="comment"># load the projection matrix. Always the same</span></span><br><span class="line">      glMatrixMode(GL_PROJECTION)</span><br><span class="line">      glLoadIdentity()</span><br><span class="line">  		glViewport(<span class="number">0</span>, <span class="number">0</span>, xSize, ySize)</span><br><span class="line">      gluPerspective(<span class="number">70</span>, aspect_ratio, <span class="number">0.1</span>, <span class="number">1000.0</span>) glTranslated(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-15</span>)</span><br></pre></td></tr></table></figure>

<p>Scene is the picture presented on the screen, the scene class is created in scene.py, the initialization code is as follows,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scene</span><span class="params">(object)</span>:</span></span><br><span class="line">    obj_list = []</span><br><span class="line">    <span class="comment"># the default depth from the camera to place an object at</span></span><br><span class="line">    PLACE_DEPTH = <span class="number">15.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The scene keeps a list of nodes that are displayed </span></span><br><span class="line">        self.node_list = list()</span><br><span class="line">        <span class="comment"># Keep track of the currently selected node.</span></span><br><span class="line">        <span class="comment"># Actions may depend on whether or not something is selected </span></span><br><span class="line">        self.selected_node = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace_node</span><span class="params">(self, nodes)</span>:</span></span><br><span class="line">        <span class="string">""" update nodes to the scene """</span> </span><br><span class="line">        self.obj_list = [] </span><br><span class="line">        self.obj_list.append(nodes)</span><br><span class="line">        self .render()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" Render the scene. """</span> </span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.node_list:</span><br><span class="line">            node.render()</span><br></pre></td></tr></table></figure>

<p>The objects rendered in the scene are all nodes in the scene. Next, define the node class and implement it in node.py.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">""" Base class for scene elements """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.color_index = random.randint(color.MIN_COLOR, color.MAX_COLOR)</span><br><span class="line">        self.aabb = AABB([<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]) </span><br><span class="line">        self.translation_matrix = numpy.identity(<span class="number">4</span>) </span><br><span class="line">        self.scaling_matrix = numpy.identity(<span class="number">4</span>) </span><br><span class="line">        self.rotating_matrix = numpy.identity(<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" renders the item to the screen """</span></span><br><span class="line">        glPushMatrix() </span><br><span class="line">        glMultMatrixf(numpy.transpose(self.translation_matrix)) 	</span><br><span class="line">        glMultMatrixf(numpy.dot(self.scaling_matrix,self.rotating_matrix)) </span><br><span class="line">        cur_color = color.COLORS[self.color_index] </span><br><span class="line">        glColor3f(cur_color[<span class="number">0</span>], cur_color[<span class="number">1</span>], cur_color[<span class="number">2</span>]) </span><br><span class="line">        self.render_self()</span><br><span class="line">        glPopMatrix()</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">render_self</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">            <span class="string">"The Abstract Node Class doesn't define 'render_self'"</span>)</span><br></pre></td></tr></table></figure>

<p>Next let’s define specific sphere class Sphere,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primitive</span><span class="params">(Node)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      	super(Primitive, self).__init__() </span><br><span class="line">        self.call_list = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render_self</span><span class="params">(self)</span>:</span> </span><br><span class="line">      	glCallList(self.call_list)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sphere</span><span class="params">(Primitive)</span>:</span></span><br><span class="line">    <span class="string">""" Sphere primitive """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">				super(Sphere, self).__init__() </span><br><span class="line">        self.call_list = G_OBJ_SPHERE</span><br></pre></td></tr></table></figure>

<p>In addition to the spherical class, this paper also uses the cylindrical Cylinder and the conical Cone, which are all redefined in Node.py. Primitive is a class between a sphere class and a node class, and an important part of the model. Implementing pirmitive in primitive.py is called the glCallList method.All specific objects such as spheres, cubes, etc. are primitives, which can be rendered by OpenGL, glNewList(CALL LIST NUMBER, GL COMPILE) and glEndList() to indicate the beginning and end of a piece of code, and associate this code with one number. Therefore you can simply use glCallList (the associated number) to call this code.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">G_OBJ_SPHERE = <span class="number">2</span></span><br><span class="line">G_OBJ_CYLINDER = <span class="number">4</span></span><br><span class="line">G_OBJ_CONE = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_sphere</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""create rendering function list for sphere object"""</span></span><br><span class="line">    glNewList(G_OBJ_SPHERE, GL_COMPILE)</span><br><span class="line">    quad = gluNewQuadric()</span><br><span class="line">    gluDeleteQuadric(quad)</span><br><span class="line">    glEndList()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cylinder</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""create rendering function list for cylinder object"""</span></span><br><span class="line">    glNewList(G_OBJ_CYLINDER, GL_COMPILE) </span><br><span class="line">    quad = gluNewQuadric() </span><br><span class="line">    gluCylinder(quad, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">1</span>, <span class="number">30</span>, <span class="number">30</span>) </span><br><span class="line">    gluDeleteQuadric(quad)</span><br><span class="line">    glEndList()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_cone</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""create rendering function list for cone object"""</span> </span><br><span class="line">    glNewList(G_OBJ_CONE, GL_COMPILE)</span><br><span class="line">    quad = gluNewQuadric()</span><br><span class="line">    gluCylinder(quad, <span class="number">0.6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">50</span>) </span><br><span class="line">    gluDeleteQuadric(quad)</span><br><span class="line">    glEndList()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_primitives</span><span class="params">()</span>:</span></span><br><span class="line">    make_sphere()</span><br><span class="line">    make_cylinder()</span><br><span class="line">    make_cone()</span><br></pre></td></tr></table></figure>

<p>Where glCallList(G_OBJ_SPHERE) produces a sphere, it can also be combined into a model structure of other complex models, that is the composite node class HierarchicalNode, which is a subclass of Node.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HierarchicalNode</span><span class="params">(Node)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       super(HierarchicalNode, self).__init__() self.child_nodes = []</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">render_self</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">for</span> child <span class="keyword">in</span> self.child_nodes:</span><br><span class="line">       		child.render()</span><br></pre></td></tr></table></figure>

<p>Particle flow is also a combination class, which is a combination of many spherical classes.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleFlow</span><span class="params">(HierarchicalNode)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nodes, magnify)</span>:</span></span><br><span class="line">       super(ParticleFlow, self).__init__() self.child_nodes = []</span><br><span class="line">       <span class="keyword">for</span> index <span class="keyword">in</span> range(len(nodes)):</span><br><span class="line">           self.child_nodes.append(Sphere())</span><br><span class="line">           self.child_nodes[index].scale(<span class="number">0.005</span>*magnify, <span class="number">0.005</span>*magnify, <span class="number">0.005</span>*magnify)</span><br><span class="line">           self.child_nodes[index].translate(nodes[index][<span class="number">0</span>]*magnify, nodes[index][<span class="number">1</span>]*magnify, nodes[index][<span class="number">2</span>]*magnify)</span><br><span class="line">           self.child_nodes[index].color_index = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>The three basic operations of translating, zooming and rotating is implemented by a change matrix in transformation.py.</p>
<p>In order to realize the user interaction with the scene, for example, to change the angle of view by dragging the mouse, to observe from different angles. Since the camera is fixed, we can only change the angle by moving the scene. Here I use the trackball algorithm to achieve. The principle of the trackball algorithm is that the origin of the world coordinate system is the center of the sphere. The scene is regarded as a ball with a sufficiently large radius, and the line of sight is unchanged. The angle of observation is changed by rotating the ball. In this article, to be brief, I use trackball defined in Glumpy directly. Use wget to download the trackball.py and store it in the working directory. The drag-to function updates the rotation matrix by taking the initial position of the mouse and the position of the mouse after the move, and stores it in the trackball.matrix of DEMPost to implement the scene. In order to rotate and update the ModelView.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix.self.trackball.drag_to(self.mouse_loc[<span class="number">0</span>], self.mouse_loc[<span class="number">1</span>], dx, dy)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>wxPython interface</li>
</ol>
<p>wxPython is a cross-platform GUI toolkit for the Python language. It is an extension of Python, and also an open source software that supports Windows, MacOS and most Unix systems and can be installed directly using pip.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install wxpython</span><br></pre></td></tr></table></figure>

<p>The GUI consists of a menu bar, a status bar, a toolbar, and a canvas. The first thing is to import wx Library, then create an application object and start the program.</p>
<p><img src="/assets/dempost/dem1.png" alt="dem1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunDemoApp</span><span class="params">(wx.App)</span>:</span> </span><br><span class="line">  	value = <span class="number">0</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">      	wx.App.__init__(self, redirect=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">"""GUI initialization"""</span></span><br><span class="line"> 		<span class="function"><span class="keyword">def</span> <span class="title">OnInit</span><span class="params">(self)</span>:</span></span><br><span class="line">				<span class="comment"># create canvas object: DemPost</span></span><br><span class="line">				canvasClass = eval(<span class="string">'DEMPost'</span>)</span><br><span class="line">				<span class="comment"># create a window</span></span><br><span class="line">				self.frame = canvasFrame(<span class="literal">None</span>, <span class="number">-1</span>, <span class="string">'DEMPost'</span>, size=(<span class="number">1000</span>,<span class="number">776</span>),pos=(<span class="number">0</span>,<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnCloseFrame</span><span class="params">(self, evt)</span>:</span> <span class="comment"># exit frame</span></span><br><span class="line">				<span class="keyword">if</span> hasattr(self, <span class="string">"window"</span>) <span class="keyword">and</span> hasattr(self.window,<span class="string">"ShutdownDemo"</span>): 	</span><br><span class="line">          	self.window.ShutdownDemo()</span><br><span class="line">				evt.Skip()</span><br><span class="line"><span class="comment"># creage an application program</span></span><br><span class="line">app = RunDemoApp() </span><br><span class="line"><span class="comment"># run the program </span></span><br><span class="line">app.MainLoop()</span><br></pre></td></tr></table></figure>

<p>I create a window canvasFrame with the size of 1000x776 and an initial position of (0, 100), which is the center of the left side of the screen. The menu bar is created in canvasFrame. The menu bar includes four drop-down menus, including File, Edit, Display and Plot. For each area of the management interface, the control panel is also required for initialization.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.panel = wx.Panel(self.frame, <span class="number">-1</span>) </span><br><span class="line">self.sizer = wx.BoxSizer(wx.HORIZONTAL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># first canvas</span></span><br><span class="line">self.canvas1 = canvasClass(self.panel) <span class="comment"># passed to MyCanvasBase </span></span><br><span class="line">self.sizer.Add(self.canvas1, <span class="number">1</span>, wx.LEFT | wx.TOP | wx.GROW)</span><br></pre></td></tr></table></figure>

<p>Subsequent canvases are based on dashboards, such as visual area layers,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">canvasFrame</span><span class="params">(wx.Frame)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,*args,**kw)</span>:</span></span><br><span class="line">				super(canvasFrame,self).__init__(*args,**kw) </span><br><span class="line">        self.InitUI()</span><br><span class="line">				plot_data = [<span class="string">'Velocity'</span>, <span class="string">'Acceleration'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InitUI</span><span class="params">(self)</span>:</span></span><br><span class="line">				menuBar = wx.MenuBar()</span><br><span class="line">				filemenu1 = wx.Menu()</span><br><span class="line">				fitem = filemenu1.Append(wx.ID_EXIT,<span class="string">"Quit"</span>,<span class="string">"Quit Applications"</span>) </span><br><span class="line">        imp = wx.MenuItem(filemenu1, <span class="number">1</span>, <span class="string">"&amp;Import\tCtrl+I"</span>)</span><br><span class="line">				obd = wx.MenuItem(filemenu1, <span class="number">2</span>, <span class="string">"&amp;Object\tCtrl+O"</span>)</span><br><span class="line">				qui = wx.MenuItem(filemenu1, <span class="number">3</span>, <span class="string">"&amp;Quit\tCtrl+Q"</span>) </span><br><span class="line">        filemenu1.Append(imp)</span><br><span class="line">				filemenu1.Append(obd)   </span><br><span class="line">				filemenu1.Append(qui)</span><br><span class="line">        </span><br><span class="line">        self.Bind(wx.EVT_MENU, self.OnQuit, id=<span class="number">3</span>) </span><br><span class="line">        menuBar.Append(filemenu1, <span class="string">'&amp;File'</span>)</span><br><span class="line">				...</span><br><span class="line">        </span><br><span class="line">     		self.SetMenuBar(menuBar)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">OnQuit</span><span class="params">(self, e)</span>:</span> </span><br><span class="line">        self.Close()</span><br></pre></td></tr></table></figure>

<p>File-&gt;Quit (shortcut Ctrl+Q), “File” use wx.Menu() first to create menu filemenu, which defines a wx.MenuItem in this drop-down menu, self.Bind(wx.EVT MENU, self.OnQuit, id=3), event binder is used to associate the Quit function with the number 3 in the menu bar and the action to exit the window; In the drop-down menu Edit, the function Edit-&gt;Zoom in(Ctrl+’+’) /Zoom out(Ctrl+’- ‘) /Leftward /Righward /Upward /Downward respectively corresponds to the translational movement of the viewing angle in the direction of the front, back, left, and right, respectively. This is done through glTranslated(x, y, z) in the OpenGl.GL interface.</p>
<p><img src="/assets/dempost/dem2.png" alt="dem2"></p>
<p>Then create a toolbar. There are four buttons on the toolbar, which are the animation start, animation pause, next frame and previous frame. The corresponding button icon exists in the working directory /Inc.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toolbar = self.frame.CreateToolBar()</span><br><span class="line">animation_tool = toolbar.AddTool(wx.ID_ANY,<span class="string">"Play"</span>,wx.Bitmap(<span class="string">"Inc/start.png"</span>)) </span><br><span class="line">suspend_tool = toolbar.AddTool(wx.ID_ANY,<span class="string">"Stop"</span>,wx.Bitmap(<span class="string">"Inc/stop.png"</span>))</span><br><span class="line">next_tool = toolbar.AddTool(wx.ID_ANY,<span class="string">"Next"</span>,wx.Bitmap(<span class="string">"Inc/next.png"</span>)) </span><br><span class="line">last_tool = toolbar.AddTool(wx.ID_ANY,<span class="string">"Last"</span>,wx.Bitmap(<span class="string">"Inc/last.png"</span>)) </span><br><span class="line">toolbar.Realize()</span><br><span class="line"></span><br><span class="line">self.Bind(wx.EVT_TOOL, self.OnClickStart, animation_tool) </span><br><span class="line">self.Bind(wx.EVT_TOOL, self.OnClickStop, suspend_tool) </span><br><span class="line">self.Bind(wx.EVT_TOOL, self.OnClickNext, next_tool) </span><br><span class="line">self.Bind(wx.EVT_TOOL, self.OnClickLast, last_tool)</span><br></pre></td></tr></table></figure>

<p>Each frame is a scene representing a certain moment, and a time series is added to obtain a time state stream. You can animate the scenes at each moment. The implementation method of this paper is to give all the time data in the scene class DEMPost, number each frame; then use the self.timer function to calculate time When the picture at this moment is updated, the modified frame number is passed to DEMPost, The data corresponding to this frame is filtered out and the picture is re-rendered; the pause of the animation is to keep the time unchanged, and the timer is turned off. At this time, the frame number is unchanged, and the scene does not change; the previous frame/next frame button is to pass the number of the previous/next frame to DEMPost and re-rendering.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnTimer</span><span class="params">(self, evt)</span>:</span></span><br><span class="line">  	<span class="keyword">if</span> self.timer.GetInterval()%<span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">try</span>: </span><br><span class="line">          	self.canvas1.setValue(self.value) </span><br><span class="line">            self.value += <span class="number">1</span></span><br><span class="line">				<span class="keyword">except</span> IndexError: </span><br><span class="line">          	canvas1.setValue(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnClickStart</span><span class="params">(self, event)</span>:</span> </span><br><span class="line"> 		self.timer.Start(<span class="number">1000</span>) </span><br><span class="line">    self.canvas1.setInterac(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnClickStop</span><span class="params">(self, event)</span>:</span> </span><br><span class="line">  	self.timer.Stop() </span><br><span class="line">    self.canvas1.setInterac(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnClickNext</span><span class="params">(self, event)</span>:</span> </span><br><span class="line">		<span class="keyword">if</span> self.timer.IsRunning():</span><br><span class="line">				self.timer.Stop() </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">				self.value += <span class="number">1</span></span><br><span class="line">				self.canvas1.setValue(self.value) </span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">				canvas1.setValue(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnClickLast</span><span class="params">(self, event)</span>:</span> </span><br><span class="line">  	<span class="keyword">if</span> self.timer.IsRunning():</span><br><span class="line">				self.timer.Stop() </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">				self.value -= <span class="number">1</span></span><br><span class="line">				self.canvas1.setValue(self.value) </span><br><span class="line">    <span class="keyword">except</span> IndexError:</span><br><span class="line">				canvas1.setValue(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

            <!-- Tags -->
            


<div class="tags">
    <a href="/tags/Visualization-DEM-OpenGL-UI/">Visualization, DEM, OpenGL, UI</a>
</div>



            <!-- Comments -->
            <div>
                




            </div>
        </div><!-- end content -->
    </section>
</section><!-- end main -->

<!-- After footer scripts -->

<!-- jQuery -->

<script src="/js/jquery.js"></script>


<!-- Custom Code -->

<script src="/js/main.js"></script>


<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>